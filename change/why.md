# why
## Number [参考](https://segmentfault.com/a/1190000008268668)
- 为什么`2**53 + 1`和`2**53`是相等的？
- 为什么`0.1+0.2`和`0.3`是不相等的？
<span style="color:red;font-weight: bold;">缘起：IEEE 754 标准定义的双精度64位格式</span>[数字存储转化](http://www.binaryconvert.com/result_double.html)

![bVIRcL?w=1406&amp;h=387](_v_images/20191113102432046_107530703.png)


```js
// 精度长度
2**53 + 1 === 2**53 //true
Number.MAX_SAFE_INTEGER === 2**53 - 1 //true 0	10000110011	1111111111111111111111111111111111111111111111111111
2**53 // 0	10000110100	0000000000000000000000000000000000000000000000000000
2**53 + 1 // 0	10000110100	0000000000000000000000000000000000000000000000000000 1
2**53 + 2 // 0	10000110100	0000000000000000000000000000000000000000000000000001 0
9007199254740993 // 9007199254740992

// 循环小数
0.1 // 0	01111111011	1001100110011001100110011001100110011001100110011010
0.2 // 0	01111111100	1001100110011001100110011001100110011001100110011010

```
总结：
1. 表示准确数字位数是52位，当精确度超过这个长度时，后面的都会被舍弃，所以会有精度问题。js中不能输出 9007199254740993
2. 循环小数

